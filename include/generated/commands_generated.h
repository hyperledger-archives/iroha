// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_
#define FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct AccountAdd;

struct AccountRemove;

struct AccountAddSignatory;

struct AccountRemoveSignatory;

struct AccountSetUseKeys;

struct AccountStore;

struct ChaincodeAdd;

struct ChaincodeRemove;

struct ChaincodeExecute;

struct AssetAdd;

struct AssetRemove;

struct AssetCreate;

struct AssetTransfer;

struct PeerAdd;

struct PeerRemove;

struct PeerSetTrust;

struct PeerChangeTrust;

struct PeerSetActive;

//////////////////////////////////////////
enum Command {
  Command_NONE = 0,
  Command_AssetCreate = 1,
  Command_AssetAdd = 2,
  Command_AssetRemove = 3,
  Command_AssetTransfer = 4,
  Command_PeerAdd = 5,
  Command_PeerRemove = 6,
  Command_PeerSetActive = 7,
  Command_PeerSetTrust = 8,
  Command_PeerChangeTrust = 9,
  Command_AccountAdd = 10,
  Command_AccountRemove = 11,
  Command_AccountAddSignatory = 12,
  Command_AccountRemoveSignatory = 13,
  Command_AccountSetUseKeys = 14,
  Command_ChaincodeAdd = 15,
  Command_ChaincodeRemove = 16,
  Command_ChaincodeExecute = 17,
  Command_MIN = Command_NONE,
  Command_MAX = Command_ChaincodeExecute
};

inline const char **EnumNamesCommand() {
  static const char *names[] = {
    "NONE",
    "AssetCreate",
    "AssetAdd",
    "AssetRemove",
    "AssetTransfer",
    "PeerAdd",
    "PeerRemove",
    "PeerSetActive",
    "PeerSetTrust",
    "PeerChangeTrust",
    "AccountAdd",
    "AccountRemove",
    "AccountAddSignatory",
    "AccountRemoveSignatory",
    "AccountSetUseKeys",
    "ChaincodeAdd",
    "ChaincodeRemove",
    "ChaincodeExecute",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<AssetCreate> {
  static const Command enum_value = Command_AssetCreate;
};

template<> struct CommandTraits<AssetAdd> {
  static const Command enum_value = Command_AssetAdd;
};

template<> struct CommandTraits<AssetRemove> {
  static const Command enum_value = Command_AssetRemove;
};

template<> struct CommandTraits<AssetTransfer> {
  static const Command enum_value = Command_AssetTransfer;
};

template<> struct CommandTraits<PeerAdd> {
  static const Command enum_value = Command_PeerAdd;
};

template<> struct CommandTraits<PeerRemove> {
  static const Command enum_value = Command_PeerRemove;
};

template<> struct CommandTraits<PeerSetActive> {
  static const Command enum_value = Command_PeerSetActive;
};

template<> struct CommandTraits<PeerSetTrust> {
  static const Command enum_value = Command_PeerSetTrust;
};

template<> struct CommandTraits<PeerChangeTrust> {
  static const Command enum_value = Command_PeerChangeTrust;
};

template<> struct CommandTraits<AccountAdd> {
  static const Command enum_value = Command_AccountAdd;
};

template<> struct CommandTraits<AccountRemove> {
  static const Command enum_value = Command_AccountRemove;
};

template<> struct CommandTraits<AccountAddSignatory> {
  static const Command enum_value = Command_AccountAddSignatory;
};

template<> struct CommandTraits<AccountRemoveSignatory> {
  static const Command enum_value = Command_AccountRemoveSignatory;
};

template<> struct CommandTraits<AccountSetUseKeys> {
  static const Command enum_value = Command_AccountSetUseKeys;
};

template<> struct CommandTraits<ChaincodeAdd> {
  static const Command enum_value = Command_ChaincodeAdd;
};

template<> struct CommandTraits<ChaincodeRemove> {
  static const Command enum_value = Command_ChaincodeRemove;
};

template<> struct CommandTraits<ChaincodeExecute> {
  static const Command enum_value = Command_ChaincodeExecute;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

//////////////////////////////////////////
/// Commands for Account
struct AccountAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4
  };
  const flatbuffers::Vector<uint8_t> *account() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ACCOUNT);
  }
  flatbuffers::Vector<uint8_t> *mutable_account() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ACCOUNT);
  }
  const iroha::Account *account_nested_root() const {
    const uint8_t* data = account()->Data();
    return flatbuffers::GetRoot<iroha::Account>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.Verify(account()) &&
           verifier.EndTable();
  }
};

struct AccountAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> account) {
    fbb_.AddOffset(AccountAdd::VT_ACCOUNT, account);
  }
  AccountAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountAddBuilder &operator=(const AccountAddBuilder &);
  flatbuffers::Offset<AccountAdd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<AccountAdd>(end);
    fbb_.Required(o, AccountAdd::VT_ACCOUNT);
    return o;
  }
};

inline flatbuffers::Offset<AccountAdd> CreateAccountAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> account = 0) {
  AccountAddBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountAdd> CreateAccountAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *account = nullptr) {
  return iroha::CreateAccountAdd(
      _fbb,
      account ? _fbb.CreateVector<uint8_t>(*account) : 0);
}

struct AccountRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4
  };
  const flatbuffers::Vector<uint8_t> *account() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ACCOUNT);
  }
  flatbuffers::Vector<uint8_t> *mutable_account() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ACCOUNT);
  }
  const iroha::Account *account_nested_root() const {
    const uint8_t* data = account()->Data();
    return flatbuffers::GetRoot<iroha::Account>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.Verify(account()) &&
           verifier.EndTable();
  }
};

struct AccountRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> account) {
    fbb_.AddOffset(AccountRemove::VT_ACCOUNT, account);
  }
  AccountRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountRemoveBuilder &operator=(const AccountRemoveBuilder &);
  flatbuffers::Offset<AccountRemove> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<AccountRemove>(end);
    fbb_.Required(o, AccountRemove::VT_ACCOUNT);
    return o;
  }
};

inline flatbuffers::Offset<AccountRemove> CreateAccountRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> account = 0) {
  AccountRemoveBuilder builder_(_fbb);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountRemove> CreateAccountRemoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *account = nullptr) {
  return iroha::CreateAccountRemove(
      _fbb,
      account ? _fbb.CreateVector<uint8_t>(*account) : 0);
}

struct AccountAddSignatory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4,
    VT_SIGNATORY = 6
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *signatory() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SIGNATORY);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_signatory() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SIGNATORY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.Verify(account()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATORY) &&
           verifier.Verify(signatory()) &&
           verifier.VerifyVectorOfStrings(signatory()) &&
           verifier.EndTable();
  }
};

struct AccountAddSignatoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(AccountAddSignatory::VT_ACCOUNT, account);
  }
  void add_signatory(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signatory) {
    fbb_.AddOffset(AccountAddSignatory::VT_SIGNATORY, signatory);
  }
  AccountAddSignatoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountAddSignatoryBuilder &operator=(const AccountAddSignatoryBuilder &);
  flatbuffers::Offset<AccountAddSignatory> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AccountAddSignatory>(end);
    fbb_.Required(o, AccountAddSignatory::VT_ACCOUNT);
    fbb_.Required(o, AccountAddSignatory::VT_SIGNATORY);
    return o;
  }
};

inline flatbuffers::Offset<AccountAddSignatory> CreateAccountAddSignatory(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signatory = 0) {
  AccountAddSignatoryBuilder builder_(_fbb);
  builder_.add_signatory(signatory);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountAddSignatory> CreateAccountAddSignatoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *signatory = nullptr) {
  return iroha::CreateAccountAddSignatory(
      _fbb,
      account ? _fbb.CreateString(account) : 0,
      signatory ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*signatory) : 0);
}

struct AccountRemoveSignatory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNT = 4,
    VT_SIGNATORY = 6
  };
  const flatbuffers::String *account() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCOUNT);
  }
  flatbuffers::String *mutable_account() {
    return GetPointer<flatbuffers::String *>(VT_ACCOUNT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *signatory() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SIGNATORY);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_signatory() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SIGNATORY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNT) &&
           verifier.Verify(account()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATORY) &&
           verifier.Verify(signatory()) &&
           verifier.VerifyVectorOfStrings(signatory()) &&
           verifier.EndTable();
  }
};

struct AccountRemoveSignatoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_account(flatbuffers::Offset<flatbuffers::String> account) {
    fbb_.AddOffset(AccountRemoveSignatory::VT_ACCOUNT, account);
  }
  void add_signatory(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signatory) {
    fbb_.AddOffset(AccountRemoveSignatory::VT_SIGNATORY, signatory);
  }
  AccountRemoveSignatoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountRemoveSignatoryBuilder &operator=(const AccountRemoveSignatoryBuilder &);
  flatbuffers::Offset<AccountRemoveSignatory> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AccountRemoveSignatory>(end);
    fbb_.Required(o, AccountRemoveSignatory::VT_ACCOUNT);
    fbb_.Required(o, AccountRemoveSignatory::VT_SIGNATORY);
    return o;
  }
};

inline flatbuffers::Offset<AccountRemoveSignatory> CreateAccountRemoveSignatory(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> account = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> signatory = 0) {
  AccountRemoveSignatoryBuilder builder_(_fbb);
  builder_.add_signatory(signatory);
  builder_.add_account(account);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountRemoveSignatory> CreateAccountRemoveSignatoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *account = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *signatory = nullptr) {
  return iroha::CreateAccountRemoveSignatory(
      _fbb,
      account ? _fbb.CreateString(account) : 0,
      signatory ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*signatory) : 0);
}

struct AccountSetUseKeys FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCOUNTS = 4,
    VT_USEKEYS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *accounts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACCOUNTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_accounts() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ACCOUNTS);
  }
  uint16_t useKeys() const {
    return GetField<uint16_t>(VT_USEKEYS, 0);
  }
  bool mutate_useKeys(uint16_t _useKeys) {
    return SetField<uint16_t>(VT_USEKEYS, _useKeys, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCOUNTS) &&
           verifier.Verify(accounts()) &&
           verifier.VerifyVectorOfStrings(accounts()) &&
           VerifyField<uint16_t>(verifier, VT_USEKEYS) &&
           verifier.EndTable();
  }
};

struct AccountSetUseKeysBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accounts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts) {
    fbb_.AddOffset(AccountSetUseKeys::VT_ACCOUNTS, accounts);
  }
  void add_useKeys(uint16_t useKeys) {
    fbb_.AddElement<uint16_t>(AccountSetUseKeys::VT_USEKEYS, useKeys, 0);
  }
  AccountSetUseKeysBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountSetUseKeysBuilder &operator=(const AccountSetUseKeysBuilder &);
  flatbuffers::Offset<AccountSetUseKeys> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AccountSetUseKeys>(end);
    fbb_.Required(o, AccountSetUseKeys::VT_ACCOUNTS);
    return o;
  }
};

inline flatbuffers::Offset<AccountSetUseKeys> CreateAccountSetUseKeys(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> accounts = 0,
    uint16_t useKeys = 0) {
  AccountSetUseKeysBuilder builder_(_fbb);
  builder_.add_accounts(accounts);
  builder_.add_useKeys(useKeys);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountSetUseKeys> CreateAccountSetUseKeysDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *accounts = nullptr,
    uint16_t useKeys = 0) {
  return iroha::CreateAccountSetUseKeys(
      _fbb,
      accounts ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*accounts) : 0,
      useKeys);
}

struct AccountStore FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *accPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCPUBKEY);
  }
  flatbuffers::String *mutable_accPubKey() {
    return GetPointer<flatbuffers::String *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *>(VT_DATA);
  }
  flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *mutable_data() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.Verify(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct AccountStoreBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<flatbuffers::String> accPubKey) {
    fbb_.AddOffset(AccountStore::VT_ACCPUBKEY, accPubKey);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data) {
    fbb_.AddOffset(AccountStore::VT_DATA, data);
  }
  AccountStoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AccountStoreBuilder &operator=(const AccountStoreBuilder &);
  flatbuffers::Offset<AccountStore> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AccountStore>(end);
    fbb_.Required(o, AccountStore::VT_ACCPUBKEY);
    fbb_.Required(o, AccountStore::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<AccountStore> CreateAccountStore(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::KeyValueObject>>> data = 0) {
  AccountStoreBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<AccountStore> CreateAccountStoreDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accPubKey = nullptr,
    const std::vector<flatbuffers::Offset<iroha::KeyValueObject>> *data = nullptr) {
  return iroha::CreateAccountStore(
      _fbb,
      accPubKey ? _fbb.CreateString(accPubKey) : 0,
      data ? _fbb.CreateVector<flatbuffers::Offset<iroha::KeyValueObject>>(*data) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Chaincode
struct ChaincodeAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  flatbuffers::Vector<uint8_t> *mutable_code() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  const iroha::Chaincode *code_nested_root() const {
    const uint8_t* data = code()->Data();
    return flatbuffers::GetRoot<iroha::Chaincode>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           verifier.EndTable();
  }
};

struct ChaincodeAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(ChaincodeAdd::VT_CODE, code);
  }
  ChaincodeAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChaincodeAddBuilder &operator=(const ChaincodeAddBuilder &);
  flatbuffers::Offset<ChaincodeAdd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ChaincodeAdd>(end);
    fbb_.Required(o, ChaincodeAdd::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<ChaincodeAdd> CreateChaincodeAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0) {
  ChaincodeAddBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChaincodeAdd> CreateChaincodeAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr) {
  return iroha::CreateChaincodeAdd(
      _fbb,
      code ? _fbb.CreateVector<uint8_t>(*code) : 0);
}

struct ChaincodeRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE = 4
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  flatbuffers::Vector<uint8_t> *mutable_code() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  const iroha::Chaincode *code_nested_root() const {
    const uint8_t* data = code()->Data();
    return flatbuffers::GetRoot<iroha::Chaincode>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           verifier.EndTable();
  }
};

struct ChaincodeRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(ChaincodeRemove::VT_CODE, code);
  }
  ChaincodeRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChaincodeRemoveBuilder &operator=(const ChaincodeRemoveBuilder &);
  flatbuffers::Offset<ChaincodeRemove> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ChaincodeRemove>(end);
    fbb_.Required(o, ChaincodeRemove::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<ChaincodeRemove> CreateChaincodeRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0) {
  ChaincodeRemoveBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChaincodeRemove> CreateChaincodeRemoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr) {
  return iroha::CreateChaincodeRemove(
      _fbb,
      code ? _fbb.CreateVector<uint8_t>(*code) : 0);
}

struct ChaincodeExecute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODE_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8
  };
  const flatbuffers::String *code_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE_NAME);
  }
  flatbuffers::String *mutable_code_name() {
    return GetPointer<flatbuffers::String *>(VT_CODE_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  flatbuffers::String *mutable_domain_name() {
    return GetPointer<flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  flatbuffers::String *mutable_ledger_name() {
    return GetPointer<flatbuffers::String *>(VT_LEDGER_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CODE_NAME) &&
           verifier.Verify(code_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           verifier.EndTable();
  }
};

struct ChaincodeExecuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code_name(flatbuffers::Offset<flatbuffers::String> code_name) {
    fbb_.AddOffset(ChaincodeExecute::VT_CODE_NAME, code_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(ChaincodeExecute::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(ChaincodeExecute::VT_LEDGER_NAME, ledger_name);
  }
  ChaincodeExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChaincodeExecuteBuilder &operator=(const ChaincodeExecuteBuilder &);
  flatbuffers::Offset<ChaincodeExecute> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ChaincodeExecute>(end);
    fbb_.Required(o, ChaincodeExecute::VT_CODE_NAME);
    fbb_.Required(o, ChaincodeExecute::VT_DOMAIN_NAME);
    fbb_.Required(o, ChaincodeExecute::VT_LEDGER_NAME);
    return o;
  }
};

inline flatbuffers::Offset<ChaincodeExecute> CreateChaincodeExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0) {
  ChaincodeExecuteBuilder builder_(_fbb);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_code_name(code_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChaincodeExecute> CreateChaincodeExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr) {
  return iroha::CreateChaincodeExecute(
      _fbb,
      code_name ? _fbb.CreateString(code_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Asset
struct AssetAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const flatbuffers::String *accPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCPUBKEY);
  }
  flatbuffers::String *mutable_accPubKey() {
    return GetPointer<flatbuffers::String *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *asset() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  flatbuffers::Vector<uint8_t> *mutable_asset() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  const iroha::Asset *asset_nested_root() const {
    const uint8_t* data = asset()->Data();
    return flatbuffers::GetRoot<iroha::Asset>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.Verify(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.EndTable();
  }
};

struct AssetAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<flatbuffers::String> accPubKey) {
    fbb_.AddOffset(AssetAdd::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset) {
    fbb_.AddOffset(AssetAdd::VT_ASSET, asset);
  }
  AssetAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetAddBuilder &operator=(const AssetAddBuilder &);
  flatbuffers::Offset<AssetAdd> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AssetAdd>(end);
    fbb_.Required(o, AssetAdd::VT_ACCPUBKEY);
    fbb_.Required(o, AssetAdd::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<AssetAdd> CreateAssetAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset = 0) {
  AssetAddBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetAdd> CreateAssetAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accPubKey = nullptr,
    const std::vector<uint8_t> *asset = nullptr) {
  return iroha::CreateAssetAdd(
      _fbb,
      accPubKey ? _fbb.CreateString(accPubKey) : 0,
      asset ? _fbb.CreateVector<uint8_t>(*asset) : 0);
}

struct AssetRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCPUBKEY = 4,
    VT_ASSET = 6
  };
  const flatbuffers::String *accPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCPUBKEY);
  }
  flatbuffers::String *mutable_accPubKey() {
    return GetPointer<flatbuffers::String *>(VT_ACCPUBKEY);
  }
  const flatbuffers::Vector<uint8_t> *asset() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  flatbuffers::Vector<uint8_t> *mutable_asset() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  const iroha::Asset *asset_nested_root() const {
    const uint8_t* data = asset()->Data();
    return flatbuffers::GetRoot<iroha::Asset>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ACCPUBKEY) &&
           verifier.Verify(accPubKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           verifier.EndTable();
  }
};

struct AssetRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_accPubKey(flatbuffers::Offset<flatbuffers::String> accPubKey) {
    fbb_.AddOffset(AssetRemove::VT_ACCPUBKEY, accPubKey);
  }
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset) {
    fbb_.AddOffset(AssetRemove::VT_ASSET, asset);
  }
  AssetRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetRemoveBuilder &operator=(const AssetRemoveBuilder &);
  flatbuffers::Offset<AssetRemove> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AssetRemove>(end);
    fbb_.Required(o, AssetRemove::VT_ACCPUBKEY);
    fbb_.Required(o, AssetRemove::VT_ASSET);
    return o;
  }
};

inline flatbuffers::Offset<AssetRemove> CreateAssetRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> accPubKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset = 0) {
  AssetRemoveBuilder builder_(_fbb);
  builder_.add_asset(asset);
  builder_.add_accPubKey(accPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetRemove> CreateAssetRemoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *accPubKey = nullptr,
    const std::vector<uint8_t> *asset = nullptr) {
  return iroha::CreateAssetRemove(
      _fbb,
      accPubKey ? _fbb.CreateString(accPubKey) : 0,
      asset ? _fbb.CreateVector<uint8_t>(*asset) : 0);
}

struct AssetCreate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET_NAME = 4,
    VT_DOMAIN_NAME = 6,
    VT_LEDGER_NAME = 8,
    VT_CREATORPUBKEY = 10
  };
  const flatbuffers::String *asset_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET_NAME);
  }
  flatbuffers::String *mutable_asset_name() {
    return GetPointer<flatbuffers::String *>(VT_ASSET_NAME);
  }
  const flatbuffers::String *domain_name() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  flatbuffers::String *mutable_domain_name() {
    return GetPointer<flatbuffers::String *>(VT_DOMAIN_NAME);
  }
  const flatbuffers::String *ledger_name() const {
    return GetPointer<const flatbuffers::String *>(VT_LEDGER_NAME);
  }
  flatbuffers::String *mutable_ledger_name() {
    return GetPointer<flatbuffers::String *>(VT_LEDGER_NAME);
  }
  const flatbuffers::String *creatorPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATORPUBKEY);
  }
  flatbuffers::String *mutable_creatorPubKey() {
    return GetPointer<flatbuffers::String *>(VT_CREATORPUBKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET_NAME) &&
           verifier.Verify(asset_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN_NAME) &&
           verifier.Verify(domain_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LEDGER_NAME) &&
           verifier.Verify(ledger_name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CREATORPUBKEY) &&
           verifier.Verify(creatorPubKey()) &&
           verifier.EndTable();
  }
};

struct AssetCreateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset_name(flatbuffers::Offset<flatbuffers::String> asset_name) {
    fbb_.AddOffset(AssetCreate::VT_ASSET_NAME, asset_name);
  }
  void add_domain_name(flatbuffers::Offset<flatbuffers::String> domain_name) {
    fbb_.AddOffset(AssetCreate::VT_DOMAIN_NAME, domain_name);
  }
  void add_ledger_name(flatbuffers::Offset<flatbuffers::String> ledger_name) {
    fbb_.AddOffset(AssetCreate::VT_LEDGER_NAME, ledger_name);
  }
  void add_creatorPubKey(flatbuffers::Offset<flatbuffers::String> creatorPubKey) {
    fbb_.AddOffset(AssetCreate::VT_CREATORPUBKEY, creatorPubKey);
  }
  AssetCreateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetCreateBuilder &operator=(const AssetCreateBuilder &);
  flatbuffers::Offset<AssetCreate> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<AssetCreate>(end);
    fbb_.Required(o, AssetCreate::VT_ASSET_NAME);
    fbb_.Required(o, AssetCreate::VT_DOMAIN_NAME);
    fbb_.Required(o, AssetCreate::VT_LEDGER_NAME);
    fbb_.Required(o, AssetCreate::VT_CREATORPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<AssetCreate> CreateAssetCreate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset_name = 0,
    flatbuffers::Offset<flatbuffers::String> domain_name = 0,
    flatbuffers::Offset<flatbuffers::String> ledger_name = 0,
    flatbuffers::Offset<flatbuffers::String> creatorPubKey = 0) {
  AssetCreateBuilder builder_(_fbb);
  builder_.add_creatorPubKey(creatorPubKey);
  builder_.add_ledger_name(ledger_name);
  builder_.add_domain_name(domain_name);
  builder_.add_asset_name(asset_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetCreate> CreateAssetCreateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset_name = nullptr,
    const char *domain_name = nullptr,
    const char *ledger_name = nullptr,
    const char *creatorPubKey = nullptr) {
  return iroha::CreateAssetCreate(
      _fbb,
      asset_name ? _fbb.CreateString(asset_name) : 0,
      domain_name ? _fbb.CreateString(domain_name) : 0,
      ledger_name ? _fbb.CreateString(ledger_name) : 0,
      creatorPubKey ? _fbb.CreateString(creatorPubKey) : 0);
}

struct AssetTransfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET = 4,
    VT_SENDER = 6,
    VT_RECEIVER = 8
  };
  const flatbuffers::Vector<uint8_t> *asset() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  flatbuffers::Vector<uint8_t> *mutable_asset() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ASSET);
  }
  const iroha::Asset *asset_nested_root() const {
    const uint8_t* data = asset()->Data();
    return flatbuffers::GetRoot<iroha::Asset>(data);
  }
  const flatbuffers::String *sender() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER);
  }
  flatbuffers::String *mutable_sender() {
    return GetPointer<flatbuffers::String *>(VT_SENDER);
  }
  const flatbuffers::String *receiver() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIVER);
  }
  flatbuffers::String *mutable_receiver() {
    return GetPointer<flatbuffers::String *>(VT_RECEIVER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.Verify(receiver()) &&
           verifier.EndTable();
  }
};

struct AssetTransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset) {
    fbb_.AddOffset(AssetTransfer::VT_ASSET, asset);
  }
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) {
    fbb_.AddOffset(AssetTransfer::VT_SENDER, sender);
  }
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) {
    fbb_.AddOffset(AssetTransfer::VT_RECEIVER, receiver);
  }
  AssetTransferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetTransferBuilder &operator=(const AssetTransferBuilder &);
  flatbuffers::Offset<AssetTransfer> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AssetTransfer>(end);
    fbb_.Required(o, AssetTransfer::VT_ASSET);
    fbb_.Required(o, AssetTransfer::VT_SENDER);
    fbb_.Required(o, AssetTransfer::VT_RECEIVER);
    return o;
  }
};

inline flatbuffers::Offset<AssetTransfer> CreateAssetTransfer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> asset = 0,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    flatbuffers::Offset<flatbuffers::String> receiver = 0) {
  AssetTransferBuilder builder_(_fbb);
  builder_.add_receiver(receiver);
  builder_.add_sender(sender);
  builder_.add_asset(asset);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssetTransfer> CreateAssetTransferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *asset = nullptr,
    const char *sender = nullptr,
    const char *receiver = nullptr) {
  return iroha::CreateAssetTransfer(
      _fbb,
      asset ? _fbb.CreateVector<uint8_t>(*asset) : 0,
      sender ? _fbb.CreateString(sender) : 0,
      receiver ? _fbb.CreateString(receiver) : 0);
}

//////////////////////////////////////////
//////////////////////////////////////////
/// Commands for Peer
struct PeerAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEER = 4
  };
  const flatbuffers::Vector<uint8_t> *peer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PEER);
  }
  flatbuffers::Vector<uint8_t> *mutable_peer() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PEER);
  }
  const iroha::Peer *peer_nested_root() const {
    const uint8_t* data = peer()->Data();
    return flatbuffers::GetRoot<iroha::Peer>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEER) &&
           verifier.Verify(peer()) &&
           verifier.EndTable();
  }
};

struct PeerAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> peer) {
    fbb_.AddOffset(PeerAdd::VT_PEER, peer);
  }
  PeerAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerAddBuilder &operator=(const PeerAddBuilder &);
  flatbuffers::Offset<PeerAdd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<PeerAdd>(end);
    fbb_.Required(o, PeerAdd::VT_PEER);
    return o;
  }
};

inline flatbuffers::Offset<PeerAdd> CreatePeerAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> peer = 0) {
  PeerAddBuilder builder_(_fbb);
  builder_.add_peer(peer);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerAdd> CreatePeerAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *peer = nullptr) {
  return iroha::CreatePeerAdd(
      _fbb,
      peer ? _fbb.CreateVector<uint8_t>(*peer) : 0);
}

struct PeerRemove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEER = 4
  };
  const flatbuffers::Vector<uint8_t> *peer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PEER);
  }
  flatbuffers::Vector<uint8_t> *mutable_peer() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PEER);
  }
  const iroha::Peer *peer_nested_root() const {
    const uint8_t* data = peer()->Data();
    return flatbuffers::GetRoot<iroha::Peer>(data);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEER) &&
           verifier.Verify(peer()) &&
           verifier.EndTable();
  }
};

struct PeerRemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> peer) {
    fbb_.AddOffset(PeerRemove::VT_PEER, peer);
  }
  PeerRemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerRemoveBuilder &operator=(const PeerRemoveBuilder &);
  flatbuffers::Offset<PeerRemove> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<PeerRemove>(end);
    fbb_.Required(o, PeerRemove::VT_PEER);
    return o;
  }
};

inline flatbuffers::Offset<PeerRemove> CreatePeerRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> peer = 0) {
  PeerRemoveBuilder builder_(_fbb);
  builder_.add_peer(peer);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerRemove> CreatePeerRemoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *peer = nullptr) {
  return iroha::CreatePeerRemove(
      _fbb,
      peer ? _fbb.CreateVector<uint8_t>(*peer) : 0);
}

struct PeerSetTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_TRUST = 6
  };
  const flatbuffers::String *peerPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERPUBKEY);
  }
  flatbuffers::String *mutable_peerPubKey() {
    return GetPointer<flatbuffers::String *>(VT_PEERPUBKEY);
  }
  double trust() const {
    return GetField<double>(VT_TRUST, 0.0);
  }
  bool mutate_trust(double _trust) {
    return SetField<double>(VT_TRUST, _trust, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.Verify(peerPubKey()) &&
           VerifyField<double>(verifier, VT_TRUST) &&
           verifier.EndTable();
  }
};

struct PeerSetTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<flatbuffers::String> peerPubKey) {
    fbb_.AddOffset(PeerSetTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_trust(double trust) {
    fbb_.AddElement<double>(PeerSetTrust::VT_TRUST, trust, 0.0);
  }
  PeerSetTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerSetTrustBuilder &operator=(const PeerSetTrustBuilder &);
  flatbuffers::Offset<PeerSetTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<PeerSetTrust>(end);
    fbb_.Required(o, PeerSetTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<PeerSetTrust> CreatePeerSetTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerPubKey = 0,
    double trust = 0.0) {
  PeerSetTrustBuilder builder_(_fbb);
  builder_.add_trust(trust);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerSetTrust> CreatePeerSetTrustDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerPubKey = nullptr,
    double trust = 0.0) {
  return iroha::CreatePeerSetTrust(
      _fbb,
      peerPubKey ? _fbb.CreateString(peerPubKey) : 0,
      trust);
}

struct PeerChangeTrust FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_DELTA = 6
  };
  const flatbuffers::String *peerPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERPUBKEY);
  }
  flatbuffers::String *mutable_peerPubKey() {
    return GetPointer<flatbuffers::String *>(VT_PEERPUBKEY);
  }
  double delta() const {
    return GetField<double>(VT_DELTA, 0.0);
  }
  bool mutate_delta(double _delta) {
    return SetField<double>(VT_DELTA, _delta, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.Verify(peerPubKey()) &&
           VerifyField<double>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct PeerChangeTrustBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<flatbuffers::String> peerPubKey) {
    fbb_.AddOffset(PeerChangeTrust::VT_PEERPUBKEY, peerPubKey);
  }
  void add_delta(double delta) {
    fbb_.AddElement<double>(PeerChangeTrust::VT_DELTA, delta, 0.0);
  }
  PeerChangeTrustBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerChangeTrustBuilder &operator=(const PeerChangeTrustBuilder &);
  flatbuffers::Offset<PeerChangeTrust> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<PeerChangeTrust>(end);
    fbb_.Required(o, PeerChangeTrust::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<PeerChangeTrust> CreatePeerChangeTrust(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerPubKey = 0,
    double delta = 0.0) {
  PeerChangeTrustBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_peerPubKey(peerPubKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerChangeTrust> CreatePeerChangeTrustDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerPubKey = nullptr,
    double delta = 0.0) {
  return iroha::CreatePeerChangeTrust(
      _fbb,
      peerPubKey ? _fbb.CreateString(peerPubKey) : 0,
      delta);
}

struct PeerSetActive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PEERPUBKEY = 4,
    VT_ACTIVE = 6
  };
  const flatbuffers::String *peerPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_PEERPUBKEY);
  }
  flatbuffers::String *mutable_peerPubKey() {
    return GetPointer<flatbuffers::String *>(VT_PEERPUBKEY);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool mutate_active(bool _active) {
    return SetField<uint8_t>(VT_ACTIVE, static_cast<uint8_t>(_active), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PEERPUBKEY) &&
           verifier.Verify(peerPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           verifier.EndTable();
  }
};

struct PeerSetActiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_peerPubKey(flatbuffers::Offset<flatbuffers::String> peerPubKey) {
    fbb_.AddOffset(PeerSetActive::VT_PEERPUBKEY, peerPubKey);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(PeerSetActive::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  PeerSetActiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PeerSetActiveBuilder &operator=(const PeerSetActiveBuilder &);
  flatbuffers::Offset<PeerSetActive> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<PeerSetActive>(end);
    fbb_.Required(o, PeerSetActive::VT_PEERPUBKEY);
    return o;
  }
};

inline flatbuffers::Offset<PeerSetActive> CreatePeerSetActive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> peerPubKey = 0,
    bool active = false) {
  PeerSetActiveBuilder builder_(_fbb);
  builder_.add_peerPubKey(peerPubKey);
  builder_.add_active(active);
  return builder_.Finish();
}

inline flatbuffers::Offset<PeerSetActive> CreatePeerSetActiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *peerPubKey = nullptr,
    bool active = false) {
  return iroha::CreatePeerSetActive(
      _fbb,
      peerPubKey ? _fbb.CreateString(peerPubKey) : 0,
      active);
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_AssetCreate: {
      auto ptr = reinterpret_cast<const AssetCreate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AssetAdd: {
      auto ptr = reinterpret_cast<const AssetAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AssetRemove: {
      auto ptr = reinterpret_cast<const AssetRemove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AssetTransfer: {
      auto ptr = reinterpret_cast<const AssetTransfer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PeerAdd: {
      auto ptr = reinterpret_cast<const PeerAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PeerRemove: {
      auto ptr = reinterpret_cast<const PeerRemove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PeerSetActive: {
      auto ptr = reinterpret_cast<const PeerSetActive *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PeerSetTrust: {
      auto ptr = reinterpret_cast<const PeerSetTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_PeerChangeTrust: {
      auto ptr = reinterpret_cast<const PeerChangeTrust *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AccountAdd: {
      auto ptr = reinterpret_cast<const AccountAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AccountRemove: {
      auto ptr = reinterpret_cast<const AccountRemove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AccountAddSignatory: {
      auto ptr = reinterpret_cast<const AccountAddSignatory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AccountRemoveSignatory: {
      auto ptr = reinterpret_cast<const AccountRemoveSignatory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_AccountSetUseKeys: {
      auto ptr = reinterpret_cast<const AccountSetUseKeys *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_ChaincodeAdd: {
      auto ptr = reinterpret_cast<const ChaincodeAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_ChaincodeRemove: {
      auto ptr = reinterpret_cast<const ChaincodeRemove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_ChaincodeExecute: {
      auto ptr = reinterpret_cast<const ChaincodeExecute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_COMMANDS_IROHA_H_
